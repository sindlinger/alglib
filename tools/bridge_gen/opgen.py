#!/usr/bin/env python3
"""
opgen.py — Gerador de exports (DLL) e .mqh de alto nível para o ALGLIB bridge

Lê src/alglib_gpu/alglib_pipe_messages.h, coleta enum Operation { NAME = code, ... }.
Abre um prompt simples para selecionar/ordenar operações (ou usa todas), e então gera:
 - src/alglib_gpu/exports_ops_generated.cpp (funções __declspec(dllexport) AlglibOp_<Name> que chamam AlglibBridge_Process)
 - MQL5/Include/pipe/AlglibOps.mqh (#import da alglib_bridge.dll com protótipos e wrappers convenientes)

Uso:
  python opgen.py --root C:\mql5\MQL5\alglib [--all]
"""
import argparse, os, re, sys, textwrap

CPP_EXPORT_TPL = textwrap.dedent('''
// AUTOGENERATED — exports_ops_generated.cpp
#include <cstdint>
extern "C" int __stdcall AlglibBridge_Process(
  unsigned int operation,
  const double* primary, int primary_len,
  const double* secondary, int secondary_len,
  const unsigned char* params, int param_len,
  double* out_primary, int out_primary_cap, int* out_primary_len,
  double* out_secondary, int out_secondary_cap, int* out_secondary_len,
  unsigned char* out_extra, int out_extra_cap, int* out_extra_len,
  int timeout_ms);

{FUNCS}
''')

CPP_FUNC_TPL = textwrap.dedent('''
extern "C" __declspec(dllexport) int __stdcall AlglibOp_{NAME}(
  const double* primary, int primary_len,
  const double* secondary, int secondary_len,
  const unsigned char* params, int param_len,
  double* out_primary, int out_primary_cap, int* out_primary_len,
  double* out_secondary, int out_secondary_cap, int* out_secondary_len,
  unsigned char* out_extra, int out_extra_cap, int* out_extra_len,
  int timeout_ms)
{
  return AlglibBridge_Process({CODE}, primary, primary_len, secondary, secondary_len,
    params, param_len, out_primary, out_primary_cap, out_primary_len,
    out_secondary, out_secondary_cap, out_secondary_len,
    out_extra, out_extra_cap, out_extra_len, timeout_ms);
}
''')

MQH_TPL = textwrap.dedent('''
// AUTOGENERATED — MQL5/Include/pipe/AlglibOps.mqh
#property strict

#import "alglib_bridge.dll"
{IMPORTS}
#import

{WRAPPERS}
''')

def parse_operations(h_path):
    txt = open(h_path, 'r', encoding='utf-8', errors='ignore').read()
    m = re.search(r'enum\s+class\s+Operation\s*:\s*std::uint32_t\s*\{(.*?)\}', txt, re.S)
    if not m:
        raise RuntimeError('Operation enum not found in ' + h_path)
    block = m.group(1)
    ops = []
    for line in block.splitlines():
        line = line.strip()
        if not line or line.startswith('//'): continue
        line = line.rstrip(',')
        parts = [p.strip() for p in line.split('=')]
        name = re.sub(r'\s+//.*$', '', parts[0]).strip()
        if not name: continue
        code = None
        if len(parts) == 2:
            code_str = re.sub(r'\s+//.*$', '', parts[1]).strip()
            try:
                code = int(code_str)
            except ValueError:
                pass
        ops.append((name, code))
    # fill missing codes by auto-increment
    filled = []
    current = -1
    for name, code in ops:
        if code is None:
            current += 1
            filled.append((name, current))
        else:
            current = code
            filled.append((name, code))
    return filled

def prompt_select(ops):
    print('Operações disponíveis:')
    for i,(n,c) in enumerate(ops,1):
        print(f'{i:2d}. {n} = {c}')
    sel = input('Selecione por índices (ex.: 1,3,5) ou ENTER para todas: ').strip()
    if not sel:
        return ops
    idx = [int(x) for x in sel.split(',') if x.strip()]
    chosen = [ops[i-1] for i in idx if 1<=i<=len(ops)]
    order = input('Nova ordem (ex.: 2,1,3) ou ENTER p/ manter: ').strip()
    if order:
        oidx = [int(x) for x in order.split(',') if x.strip()]
        chosen = [chosen[i-1] for i in oidx if 1<=i<=len(chosen)]
    return chosen

def gen_exports(ops):
    funcs = []
    for name, code in ops:
        funcs.append(CPP_FUNC_TPL.replace('{NAME}', name).replace('{CODE}', str(code)))
    return CPP_EXPORT_TPL.replace('{FUNCS}', '\n'.join(funcs))

def gen_mqh(ops):
    imports_lines = []
    wrappers = []
    for name, _ in ops:
        proto = f"AlglibOp_{name}(const double &primary[], int primary_len, const double &secondary[], int secondary_len, const uchar &params[], int param_len, double &out_primary[], int out_primary_cap, int &out_primary_len, double &out_secondary[], int out_secondary_cap, int &out_secondary_len, uchar &out_extra[], int out_extra_cap, int &out_extra_len, int timeout_ms);"
        imports_lines.append(proto)
        wrapper = (
            "string @NAME@(const double &primary[], const double &secondary[], const uchar &params[], const int timeout_ms=5000)\n"
            "  {\n"
            "    double outp[]; int outp_len=0; ArrayResize(outp, ArraySize(primary));\n"
            "    double outs[]; int outs_len=0; ArrayResize(outs, ArraySize(secondary));\n"
            "    uchar extra[]; int extra_len=0; ArrayResize(extra, 0);\n"
            "    int st = AlglibOp_@NAME@(primary, ArraySize(primary), secondary, ArraySize(secondary), params, ArraySize(params), outp, ArraySize(outp), outp_len, outs, ArraySize(outs), outs_len, extra, 0, extra_len, timeout_ms);\n"
            "    if(st!=0) return \"\";\n"
            "    // retorna payload extra como string (se existir), senão JSON vazio\n"
            "    if(extra_len>0) return CharArrayToString(extra, 0, extra_len, CP_UTF8);\n"
            "    return \"{}\";\n"
            "  }\n"
        ).replace('@NAME@', name)
        wrappers.append(wrapper)
    imports_join = '\n'.join('int   ' + line for line in imports_lines)
    return MQH_TPL.replace('{IMPORTS}', imports_join).replace('{WRAPPERS}', '\n'.join(wrappers))

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--root', required=True, help='Raiz do projeto alglib (contém src/alglib_gpu)')
    ap.add_argument('--all', action='store_true', help='Selecionar todas as operações')
    args = ap.parse_args()

    header = os.path.join(args.root, 'src', 'alglib_gpu', 'alglib_pipe_messages.h')
    if not os.path.exists(header):
        print('Não encontrei', header)
        sys.exit(1)
    ops = parse_operations(header)
    chosen = ops if args.all else prompt_select(ops)
    # gerar C++ exports
    out_cpp = gen_exports(chosen)
    cpp_path = os.path.join(args.root, 'src', 'alglib_gpu', 'exports_ops_generated.cpp')
    open(cpp_path, 'w', encoding='utf-8').write(out_cpp)
    # gerar .mqh
    mqh_path = os.path.join(args.root, '..', 'Include', 'pipe', 'AlglibOps.mqh')
    os.makedirs(os.path.dirname(mqh_path), exist_ok=True)
    open(mqh_path, 'w', encoding='utf-8').write(gen_mqh(chosen))
    print('Gerado:')
    print(' -', cpp_path)
    print(' -', mqh_path)
    print('\nAgora recompile alglib_bridge.dll via CMake e importe <pipe/AlglibOps.mqh> no indicador.')

if __name__ == '__main__':
    main()
