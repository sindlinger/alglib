#!/usr/bin/env python3
"""
opgen.py — Gerador de exports (DLL) e .mqh de alto nível para o ALGLIB bridge

Lê src/alglib_gpu/alglib_pipe_messages.h, coleta enum Operation { NAME = code, ... }.
Abre um prompt simples para selecionar/ordenar operações (ou usa todas), e então gera:
 - src/alglib_gpu/exports_ops_generated.cpp (funções __declspec(dllexport) AlglibOp_<Name> que chamam AlglibBridge_Process)
 - MQL5/Include/pipe/AlglibOps.mqh (#import da alglib_bridge.dll com protótipos e wrappers convenientes)

Uso:
  python opgen.py --root C:\mql5\MQL5\alglib [--all]
"""
import argparse, os, re, sys, textwrap
try:
    import yaml  # opcional; usado para aliases de wrappers
except Exception:
    yaml = None

CPP_EXPORT_TPL = textwrap.dedent('''
// AUTOGENERATED — exports_ops_generated.cpp
#include <cstdint>
extern "C" int __stdcall AlglibBridge_Process(
  unsigned int operation,
  const double* primary, int primary_len,
  const double* secondary, int secondary_len,
  const unsigned char* params, int param_len,
  double* out_primary, int out_primary_cap, int* out_primary_len,
  double* out_secondary, int out_secondary_cap, int* out_secondary_len,
  unsigned char* out_extra, int out_extra_cap, int* out_extra_len,
  int timeout_ms);

{FUNCS}
''')

CPP_FUNC_TPL = textwrap.dedent('''
extern "C" __declspec(dllexport) int __stdcall AlglibOp_{NAME}(
  const double* primary, int primary_len,
  const double* secondary, int secondary_len,
  const unsigned char* params, int param_len,
  double* out_primary, int out_primary_cap, int* out_primary_len,
  double* out_secondary, int out_secondary_cap, int* out_secondary_len,
  unsigned char* out_extra, int out_extra_cap, int* out_extra_len,
  int timeout_ms)
{
  return AlglibBridge_Process({CODE}, primary, primary_len, secondary, secondary_len,
    params, param_len, out_primary, out_primary_cap, out_primary_len,
    out_secondary, out_secondary_cap, out_secondary_len,
    out_extra, out_extra_cap, out_extra_len, timeout_ms);
}
''')

MQH_TPL = textwrap.dedent('''
// AUTOGENERATED — MQL5/Include/pipe/AlglibOps.mqh
#property strict

#import "alglib_bridge.dll"
{IMPORTS}
// Batch API (sempre disponível para pipelines assíncronos)
int AlglibBridge_BatchSubmit(const uint &ops[], const uint &task_flags[], const int &win_len[], const int &aux_len[], const ulong &data_off[], const ulong &param_off[], const uint &payload_hint[], int task_count, const double &data_blob[], int data_blob_len, const uchar &params_blob[], int params_blob_len, ulong &out_handle, int timeout_ms);
int AlglibBridge_BatchFetch(ulong handle, uchar &out_payload[], int out_cap, int &out_len, int &out_result_count, int timeout_ms);
#import

// Utilitários de empacotamento de parâmetros (idênticos aos usados historicamente)
union Int32Bytes { int value; uchar bytes[4]; };
union DoubleBytes { double value; uchar bytes[8]; };
void append_bytes(uchar &buffer[], int &offset, const uchar &data[], const int count)
  {
    const int needed = offset + count;
    if(ArraySize(buffer) < needed) ArrayResize(buffer, needed);
    ArrayCopy(buffer, data, offset, 0, count);
    offset += count;
  }
void append_int32(uchar &buffer[], int &offset, const int value)
  {
    Int32Bytes tmp; tmp.value = value; append_bytes(buffer, offset, tmp.bytes, 4);
  }
void append_double(uchar &buffer[], int &offset, const double value)
  {
    DoubleBytes tmp; tmp.value = value; append_bytes(buffer, offset, tmp.bytes, 8);
  }

// Wrappers genéricos por operação (retornam payload extra como string JSON quando existir)
{WRAPPERS_GENERIC}

// Wrappers de alto nível compatíveis com o indicador (Aliases)
{WRAPPERS_ALIAS}
''')

def parse_operations(h_path):
    txt = open(h_path, 'r', encoding='utf-8', errors='ignore').read()
    m = re.search(r'enum\s+class\s+Operation\s*:\s*std::uint32_t\s*\{(.*?)\}', txt, re.S)
    if not m:
        raise RuntimeError('Operation enum not found in ' + h_path)
    block = m.group(1)
    ops = []
    for line in block.splitlines():
        line = line.strip()
        if not line or line.startswith('//'): continue
        line = line.rstrip(',')
        parts = [p.strip() for p in line.split('=')]
        name = re.sub(r'\s+//.*$', '', parts[0]).strip()
        if not name: continue
        code = None
        if len(parts) == 2:
            code_str = re.sub(r'\s+//.*$', '', parts[1]).strip()
            try:
                code = int(code_str)
            except ValueError:
                pass
        ops.append((name, code))
    # fill missing codes by auto-increment
    filled = []
    current = -1
    for name, code in ops:
        if code is None:
            current += 1
            filled.append((name, current))
        else:
            current = code
            filled.append((name, code))
    return filled

def prompt_select(ops):
    print('Operações disponíveis:')
    for i,(n,c) in enumerate(ops,1):
        print(f'{i:2d}. {n} = {c}')
    sel = input('Selecione por índices (ex.: 1,3,5) ou ENTER para todas: ').strip()
    if not sel:
        return ops
    idx = [int(x) for x in sel.split(',') if x.strip()]
    chosen = [ops[i-1] for i in idx if 1<=i<=len(ops)]
    order = input('Nova ordem (ex.: 2,1,3) ou ENTER p/ manter: ').strip()
    if order:
        oidx = [int(x) for x in order.split(',') if x.strip()]
        chosen = [chosen[i-1] for i in oidx if 1<=i<=len(chosen)]
    return chosen

def gen_exports(ops):
    funcs = []
    for name, code in ops:
        funcs.append(CPP_FUNC_TPL.replace('{NAME}', name).replace('{CODE}', str(code)))
    return CPP_EXPORT_TPL.replace('{FUNCS}', '\n'.join(funcs))

def load_alias_specs(root_dir):
    """Carrega especificações de aliases (nome alto nível + parâmetros) de ops_catalog.yaml se existir.
    Formato esperado em YAML:
    aliases:
      - op: SPECTRAL_FILTER_GAUSSIAN
        name: AlglibSpectralFilterGaussian
        params:
          - { name: sigma_low, type: double }
          - { name: sigma_high, type: double }
          - { name: gain, type: double }
          - { name: mode, type: int }
    """
    fallback = [
        {'op':'SPECTRAL_FILTER_GAUSSIAN','name':'AlglibSpectralFilterGaussian','params':[
            {'name':'sigma_low','type':'double'},
            {'name':'sigma_high','type':'double'},
            {'name':'gain','type':'double'},
            {'name':'mode','type':'int'}]},
        {'op':'SPECTRAL_DENOISE','name':'AlglibSpectralDenoise','params':[
            {'name':'method','type':'int'},
            {'name':'threshold','type':'double'},
            {'name':'beta','type':'double'},
            {'name':'iterations','type':'int'}]},
        {'op':'SPECTRAL_UPSCALE','name':'AlglibSpectralUpscale','params':[
            {'name':'factor','type':'double'},
            {'name':'mode','type':'int'},
            {'name':'normalize','type':'int'}]},
        {'op':'SPECTRAL_ANALYZE','name':'AlglibAnalyzeSpectrum','params':[
            {'name':'top_k','type':'int'},
            {'name':'min_period','type':'double'},
            {'name':'max_period','type':'double'},
            {'name':'energy_threshold','type':'double'},
            {'name':'upscale_factor','type':'double'}]},
        {'op':'SPECTRAL_PHASE_UNWRAP','name':'AlglibPhaseUnwrap','params':[
            {'name':'method','type':'int'}]},
    ]
    if yaml is None:
        return fallback
    path = os.path.join(root_dir, 'tools', 'bridge_gen', 'ops_catalog.yaml')
    if not os.path.exists(path):
        return fallback
    try:
        data = yaml.safe_load(open(path, 'r', encoding='utf-8')) or {}
        return data.get('aliases', []) or []
    except Exception:
        return fallback

def gen_alias_wrapper(op_name, alias):
    """Gera wrapper de alto nível compatível com o indicador para uma operação."""
    # Mapear assinatura por op (conhecidos)
    aname = alias.get('name', f'Alglib{op_name.title()}')
    params = alias.get('params', [])
    # Montar cabeçalho e empacotamento de params
    mql_param_decl = []
    pack_lines = []
    for p in params:
        t = p.get('type','int').strip().lower()
        n = p.get('name','p')
        if t == 'double':
            mql_param_decl.append(f'double {n}')
            pack_lines.append(f'append_double(params,pofs,{n});')
        else:
            # int como padrão
            mql_param_decl.append(f'int {n}')
            pack_lines.append(f'append_int32(params,pofs,{n});')
    # Opções de retorno por operação
    if op_name == 'SPECTRAL_ANALYZE':
        ret_decl = 'double &out_magnitudes[], double &out_complex_pairs[], double &out_cycles[], double &out_instant[], double &out_transitions[]'
        after_call = textwrap.dedent('''
            ArrayResize(out_magnitudes, primary_len); ArrayCopy(out_magnitudes, primary, 0, 0, primary_len);
            ArrayResize(out_complex_pairs, secondary_len); ArrayCopy(out_complex_pairs, secondary, 0, 0, secondary_len);
            // extra não parseado aqui: manter arrays vazios por compatibilidade
            ArrayResize(out_cycles, 0);
            ArrayResize(out_instant, 0);
            ArrayResize(out_transitions, 0);
            return 0;
        ''')
    else:
        ret_decl = 'double &out_output[]'
        after_call = textwrap.dedent('''
            ArrayResize(out_output, primary_len);
            ArrayCopy(out_output, primary, 0, 0, primary_len);
            return 0;
        ''')

    wrapper = [f'int {aname}(const double &in_spectrum[], int length, ' + (', '.join(mql_param_decl) + ', ' if mql_param_decl else '') + 'double &placeholder[], int timeout_ms) { return 0; }']
    # Reescrever corretamente com buffers locais
    body = textwrap.dedent(f'''
    int {aname}(const double &in_spectrum[], int length, {', '.join(mql_param_decl + ['double &out_output[]' if op_name!='SPECTRAL_ANALYZE' else ret_decl])}, int timeout_ms)
      {{
       if(length <= 0) return -2;
       uchar params[]; int pofs=0;
       {('\n       ').join(pack_lines) if pack_lines else ''}
       double primary[]; int primary_len=0; ArrayResize(primary, length);
       double secondary[]; int secondary_len=0; ArrayResize(secondary, length);
       uchar extra[]; int extra_len=0;
       int st = AlglibOp_{op_name}(in_spectrum, length, secondary, 0, params, pofs, primary, ArraySize(primary), primary_len, secondary, ArraySize(secondary), secondary_len, extra, 0, extra_len, timeout_ms);
       if(st!=0) return st;
       {after_call}
      }}
    ''')
    return body

def gen_mqh(ops, root_dir):
    imports_lines = []
    wrappers_generic = []
    for name, _ in ops:
        proto = f"AlglibOp_{name}(const double &primary[], int primary_len, const double &secondary[], int secondary_len, const uchar &params[], int param_len, double &out_primary[], int out_primary_cap, int &out_primary_len, double &out_secondary[], int out_secondary_cap, int &out_secondary_len, uchar &out_extra[], int out_extra_cap, int &out_extra_len, int timeout_ms);"
        imports_lines.append(proto)
        w = (
            "string @NAME@(const double &primary[], const double &secondary[], const uchar &params[], const int timeout_ms=5000)\n"
            "  {\n"
            "    double outp[]; int outp_len=0; ArrayResize(outp, ArraySize(primary));\n"
            "    double outs[]; int outs_len=0; ArrayResize(outs, ArraySize(secondary));\n"
            "    uchar extra[]; int extra_len=0; ArrayResize(extra, 0);\n"
            "    int st = AlglibOp_@NAME@(primary, ArraySize(primary), secondary, ArraySize(secondary), params, ArraySize(params), outp, ArraySize(outp), outp_len, outs, ArraySize(outs), outs_len, extra, 0, extra_len, timeout_ms);\n"
            "    if(st!=0) return \"\";\n"
            "    if(extra_len>0) return CharArrayToString(extra, 0, extra_len, CP_UTF8);\n"
            "    return \"{}\";\n"
            "  }\n"
        ).replace('@NAME@', name)
        wrappers_generic.append(w)

    # Aliases compatíveis com o indicador
    aliases = load_alias_specs(root_dir)
    alias_wrappers = []
    for spec in aliases:
        op = spec.get('op'); name = spec.get('name')
        if not op or not name:
            continue
        alias_wrappers.append(gen_alias_wrapper(op, spec))

    imports_join = '\n'.join('int   ' + line for line in imports_lines)
    return MQH_TPL.replace('{IMPORTS}', imports_join) \
                   .replace('{WRAPPERS_GENERIC}', '\n'.join(wrappers_generic)) \
                   .replace('{WRAPPERS_ALIAS}', '\n'.join(alias_wrappers))

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--root', required=True, help='Raiz do projeto alglib (contém src/alglib_gpu)')
    ap.add_argument('--all', action='store_true', help='Selecionar todas as operações')
    args = ap.parse_args()

    header = os.path.join(args.root, 'src', 'alglib_gpu', 'alglib_pipe_messages.h')
    if not os.path.exists(header):
        print('Não encontrei', header)
        sys.exit(1)
    ops = parse_operations(header)
    chosen = ops if args.all else prompt_select(ops)
    # gerar C++ exports
    out_cpp = gen_exports(chosen)
    cpp_path = os.path.join(args.root, 'src', 'alglib_gpu', 'exports_ops_generated.cpp')
    open(cpp_path, 'w', encoding='utf-8').write(out_cpp)
    # gerar .mqh (com wrappers genéricos + aliases compatíveis)
    mqh_path = os.path.join(args.root, '..', 'Include', 'pipe', 'AlglibOps.mqh')
    os.makedirs(os.path.dirname(mqh_path), exist_ok=True)
    open(mqh_path, 'w', encoding='utf-8').write(gen_mqh(chosen, args.root))
    print('Gerado:')
    print(' -', cpp_path)
    print(' -', mqh_path)
    print('\nAgora recompile alglib_bridge.dll via CMake e importe <pipe/AlglibOps.mqh> no indicador.')

if __name__ == '__main__':
    main()
